import { expect } from "chai";
import { BigNumber, Contract } from "ethers";
import { deployments, ethers, waffle } from "hardhat";
import elliptic from "elliptic";
import BN = require("bn.js");
import {
  getEntryPoint,
  getSmartAccountFactory,
  getSmartAccountWithModule,
} from "../utils/setupHelper";
import { fillAndSign, getUserOpHash } from "../utils/userOp";
import { keccak256 } from "ethers/lib/utils";

const keyId = "test";
const EC = elliptic.ec;
const ec = new EC("p256");
const keyPair = ec.genKeyPair();
const pubX = "0x" + keyPair.getPublic().getX().toString("hex");
const pubY = "0x" + keyPair.getPublic().getY().toString("hex");

describe("Passkeys Registry Module:", function () {
  const [deployer, offchainSigner, charlie] = waffle.provider.getWallets();
  let passKeyModule: Contract;

  const setupTests = deployments.createFixture(async ({ deployments }) => {
    await deployments.fixture();

    const entryPoint = await getEntryPoint();
    // deploy passkey module
    passKeyModule = await (
      await ethers.getContractFactory("PasskeyRegistryModule")
    ).deploy();
    //  deploy the smart account
    const passkeyOwnershipSetupData =
      passKeyModule.interface.encodeFunctionData("initForSmartAccount", [
        pubX,
        pubY,
        keyId,
      ]);
    const userSA = await getSmartAccountWithModule(
      passKeyModule.address,
      passkeyOwnershipSetupData,
      0 // smartAccountDeploymentIndex
    );

    // send funds to userSA and mint tokens
    await deployer.sendTransaction({
      to: userSA.address,
      value: ethers.utils.parseEther("10"),
    });

    return {
      entryPoint: entryPoint,
      smartAccountFactory: await getSmartAccountFactory(),
      passkeyRegistryModule: passKeyModule,
      userSA: userSA,
    };
  });

  it("Deploys Modular Smart Account with Passkey Validation Module", async () => {
    const { userSA } = await setupTests();
    expect(await userSA.isModuleEnabled(passKeyModule.address)).to.equal(true);

    const passkeyOwner = await passKeyModule.getOwner(userSA.address);
    // verify pubX and pubY is set or not
    expect(passkeyOwner[0].valueOf()).to.equal(pubX);
    expect(passkeyOwner[1].valueOf()).to.equal(pubY);
    expect(passkeyOwner[2].valueOf()).to.equal(keyId);

    expect(await ethers.provider.getBalance(userSA.address)).to.equal(
      ethers.utils.parseEther("10")
    );
  });

  it("Can send a userOp with a passkey validation module", async () => {
    const { userSA, entryPoint } = await setupTests();
    const charlieBalanceBefore = await ethers.provider.getBalance(
      charlie.address
    );

    const txnDataAA1 = userSA.interface.encodeFunctionData("execute", [
      charlie.address,
      ethers.utils.parseEther("1"),
      "0x",
    ]);
    const userOp = await fillAndSign(
      {
        sender: userSA.address,
        callData: txnDataAA1,
        callGasLimit: 1_000_000,
        preVerificationGas: 50000,
        verificationGasLimit: 400_000,
      },
      offchainSigner, // random eoa signing the transaction
      entryPoint,
      "nonce"
    );
    userOp.signature = "";

    const keyHash = keccak256(
      ethers.utils.defaultAbiCoder.encode(["string"], ["test"])
    );
    const chainId = await entryPoint
      .provider!.getNetwork()
      .then((net) => net.chainId);
    const userOpHash = getUserOpHash(userOp, entryPoint.address, chainId);
    const clientDataJSONPre = '{"type":"webauthn.get","challenge":"';
    const clientDataJSONPost =
      '","origin":"https://webauthn.me","crossOrigin":false}';

    const userOpDataHashBuffer = Buffer.from(ethers.utils.arrayify(userOpHash));
    const opHashBase64 = userOpDataHashBuffer.toString("base64");

    const clientDataJSON = `${clientDataJSONPre}${opHashBase64}${clientDataJSONPost}`;

    const clientDataBuffer = Buffer.from(clientDataJSON);
    const clientHash = ethers.utils.sha256(
      ethers.utils.hexlify(clientDataBuffer)
    );
    // random data, on passkeys generated by the device
    const authenticatorData =
      "0x49960de5880e8c687434170f6476605b8fe4aeb9a28632c7995cf3ba831d97630500000000"; // SZYN5YgOjGh0NBcPZHZgW4_krrmihjLHmVzzuoMdl2MFAAAAAA
    const authenticatorDataBuffer = Buffer.from(
      authenticatorData.slice(2),
      "hex"
    );
    const concatenatedBuffer = Buffer.concat([
      authenticatorDataBuffer,
      Buffer.from(ethers.utils.arrayify(clientHash)),
    ]);
    // this is final data which gets reconstructed on the contract and verified
    const sigHash = ethers.utils.sha256(
      ethers.utils.hexlify(concatenatedBuffer)
    );
    const bn = new BN(BigNumber.from(sigHash).toString());
    const sign = keyPair.sign(bn);

    const signature = ethers.utils.defaultAbiCoder.encode(
      ["bytes32", "uint256", "uint256", "bytes", "string", "string"],
      [
        keyHash,
        sign.r.toString(),
        sign.s.toString(),
        authenticatorData,
        clientDataJSONPre,
        clientDataJSONPost,
      ]
    );
    const signatureWithModuleAddress = ethers.utils.defaultAbiCoder.encode(
      ["bytes", "address"],
      [signature, passKeyModule.address]
    );
    userOp.signature = signatureWithModuleAddress;

    // console.log("userOp", userOp);

    await entryPoint.handleOps([userOp], deployer.address);

    const charlieBalanceAfter = await ethers.provider.getBalance(
      charlie.address
    );
    expect(charlieBalanceAfter.sub(charlieBalanceBefore)).to.equal(
      ethers.utils.parseEther("1")
    );
  });
});
